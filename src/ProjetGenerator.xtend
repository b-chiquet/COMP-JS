/*
 * generated by Xtext 2.12.0
 */
package org.xtext.example.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.projet.AFFECT
import org.xtext.example.projet.COMMAND
import org.xtext.example.projet.COMMANDS
import org.xtext.example.projet.COMPARATOR
import org.xtext.example.projet.DEFINITION
import org.xtext.example.projet.Domainmodel
import org.xtext.example.projet.EXPRESSION
import org.xtext.example.projet.FOREACH
import org.xtext.example.projet.FOR_LOOP
import org.xtext.example.projet.FUNCTION
import org.xtext.example.projet.IF_THEN
import org.xtext.example.projet.INPUTS
import org.xtext.example.projet.NOP
import org.xtext.example.projet.OUTPUTS
import org.xtext.example.projet.VAR
import org.xtext.example.projet.WHILE

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class ProjetGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {

		// Pour toutes les fonctions du fichier
		for (f : resource.allContents.toIterable.filter(typeof(FUNCTION))) {
			// On génère un fichier pour chaque fonction présente dans le fichier
			fsa.generateFile(
				"components/" + f.name + ".whp",
				f.compile
			)
		}

		// Pour chaque fichier
		for (d : resource.allContents.toIterable.filter(typeof(Domainmodel))) {
			// On génère un nouveau fichier en appliquant la fonction compile sur tous les éléments du fichier
			fsa.generateFile(
				"file.whp",
				d.compile
			)
		}
	}

	// Pour le type "Domainmodel", qui représente tout le fichier
	def compile(Domainmodel d) {
		// On compile toutes les fonctions comprises dans le fichier une à une
		'''
			«FOR f : d.functions»
				«f.compile»
				
			«ENDFOR»
		'''
	}

	// Pour le type "FUNCTION"
	def compile(FUNCTION f) {
		// On affiche le commentaire ";Result of pretty printing process function" 
		// et le nom de la fonction, puis on compile le contenu de la fonction
		'''
			; Result of pretty printing process
			function «f.name» :
			
				«f.def.compile»
		'''
	// f.def.compile est écrit après une tabulation, ce qui va indenter tout le
	// contenu de la fonction
	}

	// Pour le type "DEFINTION"
	def compile(DEFINITION d) {
		// on affiche read input, puis le code intérieur indenté, puis write output
		'''
			read «d.inputs.compile»
			%
				«d.code.compile»
			%
			write «d.outputs.compile»
		'''
	}

	// Pour le type INPUT
	def compile(INPUTS i) {
		// Rien de particulier pour l'instant
		'''
			«i.input»
		'''
	}

	// Pour le type OUTPUT
	def compile(OUTPUTS o) {
		// Rien de particulier pour l'instant
		'''
			«o.output»
		'''
	}

	// Pour le type "COMMANDS"
	def compile(COMMANDS c) {
		// Pour les commandes (IF/NOP/AFFECT/FOR/WHILE/EACH)
		//TODO ne pas mettre un ; à la toute dernière commande
		'''
			«c.command.compile»«IF !c.commands.empty»;«ENDIF»
			«FOR line : c.commands»
				«line.compile»«IF line != c.commands.last»;«ENDIF»
			«ENDFOR»
		'''
	}

	// Pour le type "COMMAND", càd chaque commande 
	def compile(COMMAND c) {
		// Pour chaque commande, on caste dans le subtype pour le compiler
		'''
			«IF (c.eClass.name == "AFFECT")» 
				«(c as AFFECT).compile»
			«ENDIF»
			«IF (c.eClass.name == "IF_THEN")» 
				«(c as IF_THEN).compile »
			«ENDIF»
			«IF (c.eClass.name == "NOP")» 
				«(c as NOP).compile»
			«ENDIF»
			«IF (c.eClass.name == "FOR_LOOP")» 
				«(c as FOR_LOOP).compile»
			«ENDIF»
			«IF (c.eClass.name == "WHILE")» 
				«(c as WHILE).compile»
			«ENDIF»
			«IF (c.eClass.name == "FOREACH")» 
				«(c as FOREACH).compile »
			«ENDIF»
		'''
	}

	// Pour le type "AFFECT"
	def compile(AFFECT a) {
		// TODO
		// La forme doit être variable := valeur
		'''«a.variable» := «a.valeur» '''
	}

	// Pour le type "IF_THEN"
	def compile(IF_THEN if_then) {
		// TODO
		'''
		IF «if_then.cond»
		THEN «if_then.comm.compile»
		FI
		'''
		//«IF !if_then.commands2.commands.empty»ELSE«ENDIF»
		
	}

	// Pour le type "NOP"
	def compile(NOP n) {
		'''nop'''
	}
	
	def compile(FOR_LOOP fl){
		//TODO
	}
	
	def compile(WHILE w){
		//TODO
	}
	

	
	def compile(COMPARATOR c){
		//TODO
	}
	
	def compile(FOREACH fe){
		//TODO
	}
	
	def compile(VAR v){
		//TODO
		'''
		VAR
		'''
	}

	//Plus compliqué -> need bcp de modifications au niveau de la grammaire
	def compile(EXPRESSION e){
		'''expression'''
		//TODO
	}

}
